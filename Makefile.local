LOCAL_DIR=$(PWD)/local
LOCAL_CERTS = $(LOCAL_DIR)/certs
PATH:=$(LOCAL_BIN):$(PATH) # Use our local stuff first

# Tools used to run the application locally
JQ=$(LOCAL_BIN)/jq
KUBECTL=minikube kubectl --
VAULT=vault
PGO=$(LOCAL_BIN)/pgo

# This is the domain that is used for local development. You can change it to anything you want here and run init-mini
# and everything will be provisioned and setup on your development machine for that domain.
LOCAL_DOMAIN=monetr.mini
SUBDOMAINS=redis kms mail work pgadmin pghero vault ngrok registry app api

VALUES=$(PWD)/values.local.yaml
LOGIN_JWT_SECRET=$(LOCAL_DIR)/login_jwt_secret.txt
REGISTER_JWT_SECRET=$(LOCAL_DIR)/register_jwt_secret.txt

LOCAL_REST_API_DEPLOY=$(LOCAL_DIR)/rest-api-yaml

REST_API_IMAGE_NAME=monetr

$(LOCAL_DIR):
	mkdir -p $(LOCAL_DIR)

info:
	$(call infoMsg,Creating a minikube cluster for local development at: https://$(LOCAL_DOMAIN))
	$(call infoMsg,OS:   $(OS))
	$(call infoMsg,ARCH: $(ARCH))

stop-mini: $(HOSTESS)
	$(call infoMsg,Stoppping the minikube cluster)
	minikube stop || true
	$(call infoMsg,Removing our hostnames from /etc/hosts)
	for subdomain in $(SUBDOMAINS); do sudo $(HOSTESS) rm $$subdomain.$(LOCAL_DOMAIN) || true; done

clean-mini: stop-mini clean-certificates
	$(call infoMsg,Deleting the contents of the stopped cluster; makes sure our environment is clean the next time)
	minikube delete || true
	rm -rf $(VALUES) || true
	rm -rf $(PWD)/local || true
	rm -rf $(LOCAL_TMP) || true
	rm -rf $(LOCAL_BIN) || true
	$(MAKE) clean

init-mini: info
	$(call infoMsg,Setting stuff up)
	(minikube status | grep "minikube start") && $(MAKE) start-minikube
	$(MAKE) setup-hosts
	$(MAKE) deploy-services
	$(MAKE) deploy-mini-application
	$(MAKE) vault-token
	$(call infoMsg,=====================================================================================================)
	$(call infoMsg,Local environment is setup.)
	$(call infoMsg,You should be able to access monetr at:       https://app.$(LOCAL_DOMAIN))
	$(call infoMsg,)
	$(call infoMsg,Other services are run alongside monetr locally; you can access them at the following URLs:)
	$(call infoMsg,    Email:                                    https://mail.$(LOCAL_DOMAIN))
	$(call infoMsg,    Secrets:                                  https://vault.$(LOCAL_DOMAIN))
	$(call infoMsg,    PGAdmin:                                  https://pgadmin.$(LOCAL_DOMAIN))
	$(call infoMsg,    Redis:                                    https://redis.$(LOCAL_DOMAIN))
	$(call infoMsg,)
	$(call infoMsg,To develop monetr locally; run the following command in the base directory of the repository:)
	$(call infoMsg,  $ make local)
	$(call infoMsg,)
	$(call infoMsg,If you run into problems or need a clean development environment; run the following command:)
	$(call infoMsg,  $ make clean-mini)
	$(call infoMsg,This command will clean up all of the resources needed for local development and let you start over.)
	$(call infoMsg,=====================================================================================================)


# This is a bit of a hack, but on Macs we cannot run the commands needed for minikube's ingress-dns (documented here:
# https://minikube.sigs.k8s.io/docs/handbook/addons/ingress-dns/#mdns-reloading) because of System Integrity Protection.
# So we check for the protection, and if it is enabled; then we use the /etc/hosts file instead. And if it is not then
# we try to run the commands documented.
# **NOTE** This is not yet used, but it will be in the future.
CSRUTIL_STATUS=$(shell ((csrutil status | grep enabled) > /dev/null 2>&1 && echo "true") || echo "false")

setup-hosts: MINIKUBE_IP=$(shell minikube ip)
setup-hosts: $(HOSTESS) deploy-certificate
	$(call infoMsg,Registering hosts with your /etc/hosts file; these are removed upon running: make clean-mini)
	$(call infoMsg,This must be done as System Integrity Protection is enabled on your Mac and we cannot use DNS trickery. The hosts file is used instead.)
	for subdomain in $(SUBDOMAINS); do sudo $(HOSTESS) add $$subdomain.$(LOCAL_DOMAIN) $(MINIKUBE_IP); done

KEY_PATH=$(LOCAL_CERTS)/$(LOCAL_DOMAIN).key
CERT_PATH=$(LOCAL_CERTS)/$(LOCAL_DOMAIN).crt
MONETR_MINIKUBE_CERT=$(HOME)/.minikube/certs/$(LOCAL_DOMAIN).pem
clean-certificates:
	-rm -rf $(LOCAL_CERTS)
	-rm -rf $(MONETR_MINIKUBE_CERT)

$(CERT_PATH): $(LOCAL_DIR) $(MKCERT)
	mkdir -p $(LOCAL_CERTS)
	$(MKCERT) -install
	$(MKCERT) -key-file $(KEY_PATH) -cert-file $(CERT_PATH) $(LOCAL_DOMAIN) *.$(LOCAL_DOMAIN)

$(MONETR_MINIKUBE_CERT): $(CERT_PATH)
	mkdir -p $(HOME)/.minikube/certs
	openssl x509 -inform PEM -in $(CERT_PATH) > $(MONETR_MINIKUBE_CERT)

deploy-certificate: $(YQ)
deploy-certificate: NGINX_DEPLOYMENT=ingress-nginx-controller
deploy-certificate: TLS_SECRET_NAME=monetr-tls
deploy-certificate: NGINX_NAMESPACE=$(shell $(KUBECTL) get deploy --all-namespaces --field-selector "metadata.name"=$(NGINX_DEPLOYMENT) -o yaml | $(YQ) e '.items[0].metadata.namespace' -)
deploy-certificate: $(JQ) $(CERT_PATH)
	-rm -rf $(LOCAL_TMP)/nginx-*.json
	$(call infoMsg,Tweaking the nginx ingress controller to use the TLS certificate we generated by default)
	$(KUBECTL) -n $(NGINX_NAMESPACE) create secret tls $(TLS_SECRET_NAME) --key $(KEY_PATH) --cert $(CERT_PATH) \
		--dry-run=client \
		-o yaml | $(KUBECTL) apply -f -
	$(KUBECTL) rollout status deploy/$(NGINX_DEPLOYMENT) --namespace=$(NGINX_NAMESPACE) --timeout=90s
	$(KUBECTL) get deploy/$(NGINX_DEPLOYMENT) \
		--namespace=$(NGINX_NAMESPACE) -o json > $(LOCAL_TMP)/nginx-args.json
	$(JQ) '.spec.template.spec.containers[0].args |= . + ["--default-ssl-certificate=$$(POD_NAMESPACE)/$(TLS_SECRET_NAME)"]' \
		$(LOCAL_TMP)/nginx-args.json > $(LOCAL_TMP)/nginx-new.json
	cat $(LOCAL_TMP)/nginx-new.json | $(KUBECTL) apply -f -
	$(KUBECTL) rollout status deploy/$(NGINX_DEPLOYMENT) --namespace=$(NGINX_NAMESPACE) --timeout=90s
	-rm -rf $(LOCAL_TMP)/nginx-*.json

MINIKUBE_NAMESPACE=default
MINIKUBE_CPUS=4 # 4 CPU cores, could be reduced to 2.
MINIKUBE_MEMORY=8192 # 8GB of memory. Reduce if this is too high for your computer. Could be reduced to 2GB
MINIKUBE_DRIVER=hyperkit # I'm on macOS, so this will vary wildly.
MINIKUBE_KUBERNETES_VERSION=v1.19.0
start-minikube: $(MONETR_MINIKUBE_CERT)
	$(info Starting minikube)
	minikube start \
		--addons=ingress,ingress-dns,registry \
		--cpus=$(MINIKUBE_CPUS) \
		--memory=$(MINIKUBE_MEMORY) \
		--delete-on-failure \
		--driver=$(MINIKUBE_DRIVER) \
		--kubernetes-version=$(MINIKUBE_KUBERNETES_VERSION) \
		--embed-certs
	minikube update-context


$(LOGIN_JWT_SECRET): $(LOCAL_DIR)
	if [ ! -f "$(LOGIN_JWT_SECRET)" ]; then echo "Register JWT secret has not been generated, creating now" && sleep 1 && (date | md5 > $(LOGIN_JWT_SECRET)); fi

$(REGISTER_JWT_SECRET): $(LOCAL_DIR)
	if [ ! -f "$(REGISTER_JWT_SECRET)" ]; then echo "Register JWT secret has not been generated, creating now" && sleep 1 && (date | md5 > $(REGISTER_JWT_SECRET)); fi

# We want to check and see if the values file exists or is up to date.
$(VALUES):
	if [ ! -f "$(VALUES)" ]; then $(MAKE) init-mini-values; fi

init-mini-values: MINIKUBE_IP=$(shell minikube ip)
init-mini-values: REST_API_IMAGE_REPO = $(MINIKUBE_IP):5000/$(REST_API_IMAGE_NAME)
init-mini-values: $(LOGIN_JWT_SECRET) $(REGISTER_JWT_SECRET)
init-mini-values: LOGIN_JWT_SECRET_VALUE=$(shell cat $(LOGIN_JWT_SECRET))
init-mini-values: REGISTER_JWT_SECRET_VALUE=$(shell cat $(REGISTER_JWT_SECRET))
init-mini-values: $(YQ) $(HELM)
	$(call infoMsg,Setting up a basic helm values file for running the API locally)
	if [ ! -f "$(VALUES)" ]; then $(HELM) show values $(PWD) > $(VALUES); fi
	if [ -f "$(PWD)/config.yaml" ]; then $(YQ) eval '{"api": . }' $(PWD)/config.yaml | $(YQ) eval-all 'select(fileIndex == 0) * select(fileIndex == 1)' $(VALUES) - -i $(VALUES); fi
	$(YQ) e '.image.repository = "$(REST_API_IMAGE_REPO)"' -i $(VALUES)
	$(YQ) e '.ingress.enabled = false' -i $(VALUES)
	$(YQ) e '.uiService = true' -i $(VALUES)
	$(YQ) e '.service.port = 4000' -i $(VALUES)
	$(YQ) e '.service.separateUIAndAPI = true' -i $(VALUES)
	$(YQ) e '.api.includeSecrets = true' -i $(VALUES)
	$(YQ) e '.api.uiDomainName = "app.$(LOCAL_DOMAIN)"' -i $(VALUES)
	$(YQ) e '.api.apiDomainName = "app.$(LOCAL_DOMAIN)"' -i $(VALUES)
	$(YQ) e '.api.jwt.loginJwtSecret = "$(LOGIN_JWT_SECRET_VALUE)"' -i $(VALUES)
	$(YQ) e '.api.jwt.registrationJwtSecret = "$(REGISTER_JWT_SECRET_VALUE)"' -i $(VALUES)
	$(YQ) e '.api.postgreSql.address = "postgres.$(MINIKUBE_NAMESPACE).svc.cluster.local"' -i $(VALUES)
	$(YQ) e '.api.redis.address = "redis.$(MINIKUBE_NAMESPACE).svc.cluster.local"' -i $(VALUES)
	$(YQ) e '.api.cors.allowedOrigins[0] = "https://app.$(LOCAL_DOMAIN)"' -i $(VALUES)
	$(YQ) e '.api.cors.debug = false' -i $(VALUES)
	$(YQ) e '.serviceAccountName = "monetr"' -i $(VALUES)
	$(YQ) e 'del(.api.vault.tokenFile)' -i $(VALUES)
	$(YQ) e '.api.email.enabled = true' -i $(VALUES)
	$(YQ) e '.api.email.domain = "monetr.mini"' -i $(VALUES)
	$(YQ) e '.api.email.verification.enabled = true' -i $(VALUES)
	$(YQ) e '.api.email.verification.tokenLifetime = "10m"' -i $(VALUES)
	$(YQ) e '.api.email.verification.tokenSecret = "$(REGISTER_JWT_SECRET_VALUE)"' -i $(VALUES)
	$(YQ) e '.api.email.smtp.username = "restapi"' -i $(VALUES)
	$(YQ) e '.api.email.smtp.password = "mailPassword"' -i $(VALUES)
	$(YQ) e '.api.email.smtp.host = "mail.default.svc.cluster.local"' -i $(VALUES)
	$(YQ) e '.api.email.smtp.port = 1025' -i $(VALUES)
	$(YQ) e '.api comments=""' -i $(VALUES)

pg-tls-values: $(YQ)
	$(YQ) e '.api.postgreSql.caCertificatePath = "/tls/ca.crt"' -i $(VALUES)
	$(YQ) e '.api.postgreSql.certificatePath = "/tls/tls.crt"' -i $(VALUES)
	$(YQ) e '.api.postgreSql.keyPath = "/tls/tls.key"' -i $(VALUES)
	$(YQ) e '.extraVolumes[0].name = "ssl"' -i $(VALUES)
	$(YQ) e '.extraVolumes[0].secret.secretName = "postgres-api-tls"' -i $(VALUES)
	$(YQ) e '.extraVolumeMounts[0].name = "ssl"' -i $(VALUES)
	$(YQ) e '.extraVolumeMounts[0].mountPath = "/tls"' -i $(VALUES)
	$(YQ) e '.api.customEnv[0].name = "MONETR_PG_PASSWORD"' -i $(VALUES)
	$(YQ) e '.api.customEnv[0].valueFrom.secretKeyRef.key = "password"' -i $(VALUES)
	$(YQ) e '.api.customEnv[0].valueFrom.secretKeyRef.name = "postgres-postgres-secret"' -i $(VALUES)

update-coredns:
	$(call infoMsg,Updating CoreDNS config)
	$(KUBECTL) apply -f $(PWD)/minikube/coredns-config.yaml --namespace=kube-system
	$(KUBECTL) rollout restart deploy/coredns --namespace=kube-system
	$(KUBECTL) rollout status deploy/coredns --namespace=kube-system --timeout=180s

deploy-certmanager: CERT_MANAGER_VERSION=v1.3.1
deploy-certmanager: CERT_MANAGER_URL = https://github.com/jetstack/cert-manager/releases/download/$(CERT_MANAGER_VERSION)/cert-manager.yaml
deploy-certmanager: CERT_MANAGER_NAMESPACE=cert-manager
deploy-certmanager:
	$(call infoMsg,Deploying cert-manager)
	$(KUBECTL) apply -f $(CERT_MANAGER_URL)
	$(KUBECTL) rollout status deploy/cert-manager --namespace $(CERT_MANAGER_NAMESPACE) --timeout=120s
	$(KUBECTL) rollout status deploy/cert-manager-cainjector --namespace $(CERT_MANAGER_NAMESPACE) --timeout=120s
	$(KUBECTL) rollout status deploy/cert-manager-webhook --namespace $(CERT_MANAGER_NAMESPACE) --timeout=120s

ROOT_CA_KEY=$(LOCAL_DIR)/root.key
$(ROOT_CA_KEY):
	@if [ ! -f "$(ROOT_CA_KEY)" ]; then make _generate-$(ROOT_CA_KEY); fi

_generate-$(ROOT_CA_KEY): $(LOCAL_DIR)
	$(call infoMsg,Generating new root CA key)
	openssl ecparam -genkey -name secp521r1 -noout -out $(ROOT_CA_KEY)

ROOT_CA_CRT=$(LOCAL_DIR)/root.crt
$(ROOT_CA_CRT):
	@if [ ! -f "$(ROOT_CA_CRT)" ]; then make _generate-$(ROOT_CA_CRT); fi

_generate-$(ROOT_CA_CRT): $(LOCAL_DIR) $(ROOT_CA_KEY)
	$(call infoMsg,Generating new root CA certificate)
	openssl req -x509 -new -SHA256 -nodes \
		-key $(ROOT_CA_KEY) \
		-days 365 \
		-out $(ROOT_CA_CRT) \
		-subj "/C=US/ST=Minnesota/L=Lindstrom/O=monetr LLC/OU=Engineering/CN=monetr.in"

deploy-certificate-authority: $(ROOT_CA_KEY) $(ROOT_CA_CRT)
	$(call infoMsg,Installing custom certificate authority)
	$(KUBECTL) create secret generic monetr-ca \
		--from-file=tls.crt=$(ROOT_CA_CRT) \
		--from-file=tls.key=$(ROOT_CA_KEY) \
		--namespace=$(MINIKUBE_NAMESPACE) \
		--dry-run=client -o yaml | $(KUBECTL) apply -f -
	$(KUBECTL) create secret generic monetr-ca-crt \
		--from-file=ca.crt=$(ROOT_CA_CRT) \
		--namespace=$(MINIKUBE_NAMESPACE) \
		--dry-run=client -o yaml | $(KUBECTL) apply -f -
	$(KUBECTL) apply -f $(PWD)/minikube/ca-issuer.yaml --namespace=$(MINIKUBE_NAMESPACE)
	$(MAKE) postgres-certificates

postgres-certificates:
	$(call infoMsg,Generating PostgreSQL TLS certificates)
	$(KUBECTL) apply -f $(PWD)/minikube/postgres-certificate.yaml --namespace $(MINIKUBE_NAMESPACE)

deploy-redis:
	$(call infoMsg,Deploying Redis into the minikube cluster)
	$(KUBECTL) apply -f $(PWD)/minikube/redis.yaml --namespace $(MINIKUBE_NAMESPACE)
	$(KUBECTL) rollout status deploy/redis --namespace $(MINIKUBE_NAMESPACE) --timeout=120s

deploy-postgres:
	$(call infoMsg,Deploying PostgreSQL to the minikube cluster)
	$(KUBECTL) apply -f $(PWD)/minikube/postgres.yaml -n $(MINIKUBE_NAMESPACE)
	$(KUBECTL) rollout status deploy/postgres --namespace $(MINIKUBE_NAMESPACE) --timeout=120s

deploy-pgadmin:
	$(call infoMsg,Deploying PGAdmin to the minikube cluster)
	$(KUBECTL) apply -f $(PWD)/minikube/pgadmin.yaml -n $(MINIKUBE_NAMESPACE)
	$(KUBECTL) rollout status deploy/pgadmin --namespace $(MINIKUBE_NAMESPACE) --timeout=120s

deploy-services: deploy-certmanager update-coredns deploy-redis deploy-postgres mail-mini vault-mini deploy-pgadmin
	$(MAKE) deploy-certificate-authority

SHELL_IMAGE=ghcr.io/elliotcourant/dotfiles/ubuntu:latest
shell:
	$(KUBECTL) run shell-$(shell date +%Y%m%d%H%M%s) \
		--image-pull-policy=Always \
		--rm -ti --image=$(SHELL_IMAGE) \
	 	-n $(MINIKUBE_NAMESPACE) --

$(LOCAL_REST_API_DEPLOY):
	mkdir -p $(LOCAL_REST_API_DEPLOY)

build-rest-api-mini: GO_HASH=$(shell find -s $(PWD)/pkg -type f -exec shasum {} \; | shasum | cut -d " " -f 1)
build-rest-api-mini: LOCAL_RELEASE_STR=$(shell printf "LOCAL-%s-%s" $$(date -u +%Y.%m.%d.%H.%M) $$(git config user.email))
build-rest-api-mini: MINIKUBE_IP=$(shell minikube ip)
build-rest-api-mini: BASE_IMAGE_NAME=$(MINIKUBE_IP):5000/$(REST_API_IMAGE_NAME)
build-rest-api-mini: IMAGE_NAME = $(BASE_IMAGE_NAME):$(GO_HASH)
build-rest-api-mini: wait-for-docker $(YQ) $(STATIC_DIR)
	eval $$(minikube docker-env) && docker build \
		--build-arg GOFLAGS="-tags=mini" \
		--build-arg REVISION=$(RELEASE_REVISION) \
		--build-arg BUILD_TIME=$(BUILD_TIME) \
		--build-arg RELEASE=$(LOCAL_RELEASE_STR) \
		-t $(IMAGE_NAME) \
		-f Dockerfile .
	$(YQ) e '.image.tag = "$(GO_HASH)"' -i $(VALUES)

deploy-mini-application: $(VALUES)
deploy-mini-application: CONFIG_HASH=$(shell md5 -q $(VALUES))
deploy-mini-application: $(HELM) $(LOCAL_REST_API_DEPLOY) build-rest-api-mini $(YQ) $(SPLIT_YAML)
	$(KUBECTL) apply -f $(PWD)/minikube/ingress.yaml --namespace $(MINIKUBE_NAMESPACE)
	$(YQ) e '.podAnnotations.configHash = "$(CONFIG_HASH)"' -i $(VALUES)
	$(HELM) template $(REST_API_IMAGE_NAME) $(PWD) \
 		--dry-run \
 		--values=$(VALUES) | $(SPLIT_YAML) --outdir $(LOCAL_REST_API_DEPLOY) -
	$(KUBECTL) delete svc/$(REST_API_IMAGE_NAME)-api --namespace $(MINIKUBE_NAMESPACE) || true
	$(KUBECTL) apply -f $(LOCAL_REST_API_DEPLOY) --namespace $(MINIKUBE_NAMESPACE)
	$(KUBECTL) rollout status deploy/$(REST_API_IMAGE_NAME) --namespace $(MINIKUBE_NAMESPACE) --timeout=30s

local-postgres-certs:
	mkdir -p $(LOCAL_DIR)/postgres
	$(KUBECTL) get secret postgres-api-tls -o jsonpath='{.data.ca\.crt}' -n $(MINIKUBE_NAMESPACE) | base64 -d > $(LOCAL_DIR)/postgres/ca.crt
	$(KUBECTL) get secret postgres-api-tls -o jsonpath='{.data.tls\.crt}' -n $(MINIKUBE_NAMESPACE) | base64 -d > $(LOCAL_DIR)/postgres/tls.crt
	$(KUBECTL) get secret postgres-api-tls -o jsonpath='{.data.tls\.key}' -n $(MINIKUBE_NAMESPACE) | base64 -d > $(LOCAL_DIR)/postgres/tls.key


###################### WORKING ON WEBHOOKS LOCALLY ##################################
webhooks-mini:
ifndef NGROK_AUTH
	$(error Must specify NGROK_AUTH to setup webhooks)
	exit 100
endif
	$(KUBECTL) create secret generic ngrok-auth-secret \
		--from-literal=NGROK_AUTH=$(NGROK_AUTH) \
		--dry-run=client -o yaml | $(KUBECTL) apply -f - \
		--namespace $(MINIKUBE_NAMESPACE)
	$(KUBECTL) apply -f $(PWD)/minikube/ngrok.yaml \
		--namespace $(MINIKUBE_NAMESPACE)
	$(KUBECTL) rollout status deploy/ngrok \
		--namespace $(MINIKUBE_NAMESPACE) --timeout=60s
	@sleep 15 # Wait for ngrok to setup its public url.
	@echo "\033[0;31m#################################################################################\033[0m"
	@echo "ngrok inspector is now accessible at: https://ngrok.$(LOCAL_DOMAIN)"
	@echo "run: make reconfigure-webhooks"
	@echo "to apply config changes for the ngrok url"
	@echo "\033[0;31m#################################################################################\033[0m"

configure-stripe-webhooks:
	$(YQ) e '.api.stripe.webhooksEnabled = true' -i $(VALUES)
	$(MAKE) deploy-mini-application

reconfigure-webhooks: $(JQ)
reconfigure-webhooks: NGROK_DOMAIN = $(shell curl -s "https://ngrok.$(LOCAL_DOMAIN)/api/tunnels" | $(JQ) '.tunnels[] | select( .name =="command_line").public_url' - -r)
reconfigure-webhooks: WEBHOOKS_DOMAIN=$(subst https://,,$(NGROK_DOMAIN))
reconfigure-webhooks: $(YQ)
	$(YQ) e '.api.plaid.webhooksDomain = "$(WEBHOOKS_DOMAIN)"' -i $(VALUES) && \
	$(YQ) e '.api.stripe.webhooksEnabled = true' -i $(VALUES)
	$(YQ) e '.api.plaid.webhooksEnabled = true' -i $(VALUES)
	$(MAKE) deploy-mini-application

disable-webhooks-mini: $(YQ)
	$(YQ) e '.api.plaid.webhooksEnabled = false' -i $(VALUES)
	$(YQ) e '.api.stripe.webhooksEnabled = false' -i $(VALUES)
	$(MAKE) deploy-mini-application
	$(KUBECTL) delete deploy/ngrok --namespace $(MINIKUBE_NAMESPACE)



###################### POSTGRESQL ANALYTICS ##################################
pghero-mini:
	$(KUBECTL) apply -f $(PWD)/minikube/pghero.yaml \
		--namespace $(MINIKUBE_NAMESPACE)
	$(KUBECTL) rollout status deploy/pghero \
		--namespace $(MINIKUBE_NAMESPACE) --timeout=60s
	@echo "\033[0;31m#################################################################################\033[0m"
	@echo "pghero dashboard is now accessible at: https://pghero.$(LOCAL_DOMAIN)"
	@echo "\033[0;31m#################################################################################\033[0m"

###################### VAULT SECRETS ##################################
VAULT_JSON=$(LOCAL_DIR)/vault-keys.json
vault-mini:
	$(KUBECTL) apply -f $(PWD)/minikube/vault.yaml \
		--namespace $(MINIKUBE_NAMESPACE)
	$(MAKE) unseal-vault-mini
	$(KUBECTL) rollout status deploy/vault \
		--namespace $(MINIKUBE_NAMESPACE) --timeout=60s
	$(MAKE) vault-terraform
	$(MAKE) vault-token
	$(MAKE) $(VAULT_SERVICE_ACCOUNT)
	$(MAKE) configure-vault

vault-token: $(VAULT_JSON) $(JQ)
	@echo "\033[0;31m#################################################################################\033[0m"
	@echo "vault is now accessible at: https://vault.$(LOCAL_DOMAIN)"
	@echo "root token: $$(cat $(VAULT_JSON) | $(JQ) -r '.root_token')"
	@echo "\033[0;31m#################################################################################\033[0m"

vault-terraform: $(VAULT_JSON) $(wildcard $(PWD)/minikube/vault/*.tf)
vault-terraform: $(JQ)
vault-terraform: VAULT_TOKEN=$(shell cat $(VAULT_JSON) | $(JQ) -r '.root_token')
vault-terraform: KUBE_ADDR=$(shell minikube ip)
vault-terraform: KUBE_CTX=$(shell $(KUBECTL) config current-context)
vault-terraform: KUBE_CERT_B64=$(shell cat $(HOME)/.minikube/ca.crt | base64)
vault-terraform: SERVICE_ACCOUNT_SECRET_NAME=$(shell $(KUBECTL) get serviceaccount vault-authentication -o yaml | $(YQ) e '.secrets[0].name' -)
vault-terraform: REVIEWER_JWT=$(shell $(KUBECTL) get secret $(SERVICE_ACCOUNT_SECRET_NAME) -o yaml | $(YQ) e '.data.token' - | base64 -d)
vault-terraform:
	export VAULT_TOKEN=$(VAULT_TOKEN) && \
	export TF_VAR_kubernetes_address="https://$(KUBE_ADDR):8443" && \
	export TF_VAR_kubernetes_certificate_b64=$(KUBE_CERT_B64) && \
	export TF_VAR_kubernetes_reviewer_jwt=$(REVIEWER_JWT) && \
	cd $(PWD)/minikube/vault && terraform init -upgrade && terraform apply -auto-approve=true

define waitForContainer
while [[ $$($(KUBECTL) get pod $$($(KUBECTL) get pod -l $1 --namespace $(MINIKUBE_NAMESPACE) -o 'jsonpath={.items[0].metadata.name}') -o 'jsonpath={.status.phase}') != "Running" ]]; do echo "Waiting for container..." && sleep 5; done
endef

$(VAULT_JSON):
	$(call infoMsg,Waiting for vault to be running.)
	$(call waitForContainer,app.kubernetes.io/name=vault,vault)
	$(call infoMsg,Initializing vault.)
	$(KUBECTL) exec deploy/vault --namespace $(MINIKUBE_NAMESPACE) -- vault operator init -key-shares=1 -key-threshold=1 --tls-skip-verify -format=json > $(VAULT_JSON)

VAULT_SERVICE_ACCOUNT=$(LOCAL_DIR)/vault-service-account-token
$(VAULT_SERVICE_ACCOUNT): $(YQ)
$(VAULT_SERVICE_ACCOUNT): SECRET_NAME=$(shell $(KUBECTL) get serviceaccounts monetr --namespace $(MINIKUBE_NAMESPACE) -o yaml | $(YQ) e '.secrets[0].name' -)
$(VAULT_SERVICE_ACCOUNT): TOKEN=$(shell $(KUBECTL) get secrets $(SECRET_NAME) --namespace $(MINIKUBE_NAMESPACE) -o yaml | $(YQ) e '.data.token' - | base64 -d)
$(VAULT_SERVICE_ACCOUNT): $(LOCAL_DIR)
	echo "$(TOKEN)" >> $(VAULT_SERVICE_ACCOUNT)

unseal-vault-mini: $(VAULT_JSON) $(JQ)
	$(eval VAULT_UNSEAL_KEY = $(shell cat $(VAULT_JSON) | $(JQ) -r ".unseal_keys_b64[]"))
	$(KUBECTL) exec deploy/vault -- vault status --tls-skip-verify || $(KUBECTL) exec deploy/vault -- vault operator unseal --tls-skip-verify $(VAULT_UNSEAL_KEY)

configure-vault: $(VAULT_JSON) $(YQ) $(VALUES)
	$(YQ) e '.api.vault.enabled = true' -i $(VALUES)
	$(YQ) e '.api.vault.address = "http://vault.$(MINIKUBE_NAMESPACE).svc.cluster.local"' -i $(VALUES)
	$(YQ) e '.api.vault.role = "monetr"' -i $(VALUES)
	$(YQ) e 'del(.api.vault.tokenFile)' -i $(VALUES)

clean-vault-mini:
	rm -rf $(VAULT_JSON)
	$(KUBECTL) delete -f $(PWD)/minikube/vault.yaml -n $(MINIKUBE_NAMESPACE)

###################### gocraft/work UI ##################################
WORK_IMAGE_NAME=registry.$(LOCAL_DOMAIN)/work
work-mini:
	eval $$(minikube docker-env) && docker build \
		--cache-from=$(WORK_IMAGE_NAME):latest \
		-t $(WORK_IMAGE_NAME):latest \
		-f Dockerfile.work . && \
		docker push $(WORK_IMAGE_NAME):latest
	$(KUBECTL) apply -f $(PWD)/minikube/work.yaml \
		--namespace $(MINIKUBE_NAMESPACE)
	$(KUBECTL) rollout status deploy/work \
		--namespace $(MINIKUBE_NAMESPACE) --timeout=60s
	@echo "\033[0;31m#################################################################################\033[0m"
	@echo "gocraft/work dashboard is now accessible at: https://work.$(LOCAL_DOMAIN)"
	@echo "\033[0;31m#################################################################################\033[0m"

###################### Mailhog UI ##################################
mail-mini: $(VALUES) $(YQ)
	$(KUBECTL) apply -f $(PWD)/minikube/mailhog.yaml \
		--namespace $(MINIKUBE_NAMESPACE)
	$(KUBECTL) rollout status deploy/mail \
		--namespace $(MINIKUBE_NAMESPACE) --timeout=60s
	$(YQ) e '.api.smtp.enabled = true' -i $(VALUES)
	$(YQ) e '.api.smtp.username = "restapi"' -i $(VALUES)
	$(YQ) e '.api.smtp.password = "mailPassword"' -i $(VALUES)
	$(YQ) e '.api.smtp.host = "mail.default.svc.cluster.local"' -i $(VALUES)
	$(YQ) e '.api.smtp.port = 1025' -i $(VALUES)






.PHONY: local _local_ local-down
local: LOCAL_IP=$(shell ifconfig | grep -E "([0-9]{1,3}\.){3}[0-9]{1,3}" | grep -v 127.0.0.1 | awk '{ print $$2 }' | cut -f2 -d: | head -n1)
local: $(YQ)
	$(YQ) e '.subsets[0].addresses[0].ip = "$(LOCAL_IP)"' $(PWD)/minikube/api-endpoint.yaml | $(KUBECTL) apply -f -
	$(YQ) e '.subsets[0].addresses[0].ip = "$(LOCAL_IP)"' $(PWD)/minikube/ui-endpoint.yaml | $(KUBECTL) apply -f -
	$(KUBECTL) get svc/$(REST_API_IMAGE_NAME)-api -n $(MINIKUBE_NAMESPACE) -o yaml | $(YQ) e 'del(.spec.selector)' - | $(KUBECTL) apply -f -
	$(KUBECTL) get svc/$(REST_API_IMAGE_NAME)-ui -n $(MINIKUBE_NAMESPACE) -o yaml | $(YQ) e 'del(.spec.selector)' - | $(KUBECTL) apply -f -
	$(KUBECTL) get svc/$(REST_API_IMAGE_NAME)-ui -n $(MINIKUBE_NAMESPACE) -o yaml | $(YQ) e '.spec.ports[0].targetPort = 30000' - | $(KUBECTL) apply -f -
	$(KUBECTL) scale deploy/$(REST_API_IMAGE_NAME) --replicas=0 -n $(MINIKUBE_NAMESPACE)
ifdef TMUX
	$(call warningMsg,Setting up minikube tunnel and webpack dev server in a separate session; if you want to stop this kill the monetr-local tmux session and run make local-down.)
	$(MAKE) _local_
else
	$(call warningMsg,Setting up minikube tunnel and webpack dev server for local development; use CTRL-C to stop and cleanup.)
	-bash -c "trap '$(MAKE) local-down' EXIT; $(MAKE) _local_"
endif

local-down:
	$(KUBECTL) delete svc/$(REST_API_IMAGE_NAME)-api --namespace $(MINIKUBE_NAMESPACE)
	$(KUBECTL) delete svc/$(REST_API_IMAGE_NAME)-ui --namespace $(MINIKUBE_NAMESPACE)
	$(KUBECTL) apply -f $(LOCAL_REST_API_DEPLOY) --namespace $(MINIKUBE_NAMESPACE)
	$(KUBECTL) scale deploy/$(REST_API_IMAGE_NAME) --replicas=1 -n $(MINIKUBE_NAMESPACE)
	$(KUBECTL) rollout status deploy/$(REST_API_IMAGE_NAME) --namespace $(MINIKUBE_NAMESPACE) --timeout=60s

_local_:
	-tmux has-session -t monetr-local && tmux kill-session -t monetr-local
ifndef TMUX
	tmux new -d -s monetr-local 'yarn start' \; attach -t monetr-local \; \
		split-window 'minikube tunnel --cleanup=true' \;
else
	tmux new -d -s monetr-local 'yarn start' \; switch -t monetr-local \; \
		split-window 'minikube tunnel --cleanup=true' \;
endif
